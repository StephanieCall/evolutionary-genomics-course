---
title: "Lab9A_SNC"
author: "Stephanie Call"
date: "10/26/2020"
output: html_document
bibliography: data/references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Regular expressions (regex) are concise sequence of characters that are used to define a search pattern for strings, like in a find operation for a document. There are different syntaxes used to define regular expressions, such as POSIX standards or Perl syntax. 

# Base R Functions

R's base regular expression functions work similarly as in other languages. You can read about them in the main help page via ?regexp. As an overview, you can check the cheat sheet for Base R regular expressions. Additionally, here are the basic functions - 

grep() and grepl() - Search for matches of a regular expression in a character vector. grep() returns the indices that contain a match or strings that have a match. grepl() returns a logic vector to indicate which strings have a match vs don't.

regexpr() and gregexpr() - Search a character vector for matches and return the indices of the string where the match begins and the length of the match. gregexpr() returns the starting positions of every (disjointed, aka non-overlapping) match.

sub() and gsub() - Search a character vector for matches and replace the match with another string. gsub() replaces all matches while sub() only replaces the first.

regexec() - Search a character fector for a regular expression like regexpr(), but also return the locations for any parenthesized subexpressions.

The default syntax for R is POSIX 1003.2 extended regular expressions, but Perl syntax can be set using perl = TRUE argument.


# The stringr Package

stringr is a package part of tidyverse that wraps the underlying stringi package, which provides a series of convenience functions that hides some of the complexities of the base R regular expression functions. In general, stringr functions provide a more rational interface to regular expressions with more consistent arguments and argument ordering. In general, the data are the first argument and regular expression the second. The mapping between base R and stringr functions is straigtforward - 
str_subset() is like grep(value = TRUE), returning a character vector of strings that have the input match.
str_detect() is nearly equivalent ot grepl().
str_extract() is like regexpr() and regmatches(), extracted matches for the output.
str_match() is similar to regexec() by providing a matrix of parenthesized suexpressions.

You can find cheat sheets for stringr and read more about it on its tidyverse page.

Now, we will go over stringr via a shortened version of the Strings chapter in R for Data Science by Hadley Wickham (@R_for_Data_Science).

```{r import}
library(stringr)
library(tidyverse)
```


# 14.3 Matching patterns with regular expressions

To learn the basics of regular expressions, we will start with str_viwe() and str_view_all(), which take a character vector and regular expression and highlight the matches in the input character vector.

## 14.3.1 Basic matches 

The most basic is exact string matches.

```{r exact_match}
x <- c('apple', 'banana', 'pear')
str_view(x, 'an') # search for 'an', matching the first instance only
```

Now, increase complexity with the dot, ".", which matches any character except newline.

```{r dot}
str_view(x, '.a.') # search for the first instance of a surrounded by two characters
```

To match a regular expression character, like dot, need to use an escape character. In R, like in Python, this uses the backslash, "\\", character. However, because the regular expression is a string and strings also use backslash to escape characters, two backslashes, '\\\\', must be used before the character that is being searched for in the regular expression.

```{r escape}
# To create the regular expression, define the dot escape character for ease using \\.
dot <- "\\."

# Now, the expression itself only contains one backslash - 
writeLines(dot)

# This tells R to search for the only the dot, .
x <- c('abc', 'a.c', 'bef')
str_view(x, 'a\\.c')
# Now, if we only search for dot, we will only match the dot - 
str_view(x, dot)
```

To match the backslash, you need to escape the backslash itself with \\. This is easy enough when it is inside an expression (such as a\\b). However, when you only want to match the backslash, you need to escape the backslash and the surrounding quotes in the string, which adds to a total of 4 backslashes to just match the backslash itself.

```{r escape_backslash}
x <- 'a\\b'
writeLines(x)
str_view(x, '\\\\')
# To match the a\\b in the regular expression, you need to use four backslashes (two are 
# used to escape the backslashes, leaving two left to match the string)
str_view(x, 'a\\\\b')
```

## 14.3.1.1 Exercises

1 - Explain why each of these strings don't match backslash, \\: 

"\\" doesn't match because the escape character (backslash) just escape the end quote that defines the string, leaving a hanging quote and, thus, not even defining a string.

"\\\\" doesn't match a string because the input string to the regular expression is a single backslash, which is processed to nothing by the regex syntax language. Therefore, nothing can match. 
"\\\\\\" doesn't match because the third backslash escape the end quotes, leaving a hanging quote and, thus, not defining a string (similar to the first expression). 


2 - How would you match the sequence "'\\?

To match that sequence, use: "\\"'\\\\\\\\". This will escape the escape character and quote when making the string, then escape the escape character when creating the regular expression. As proof - 

```{r Ex_1-2}
match <- "\"'\\\\"
writeLines(match)
str_view('"\'\\', match)
```


3 - What pattern will the regular expression \\..\\..\\.. match? How would you represent it as a string?

This regex would match the string pattern of .[any single character].[any single character].[any single character]. For example, .a.a.a. To create this regular expression as a string, use: "\\\\..\\\\..\\\\.." As proof - 

```{r Ex_1-3}
match <- '\\..\\..\\..'
writeLines(match)
str_view('.a.a.a', match)
```

Basically, the pattern for escaping characters is - You lose one escape character per escape character chunk when creating the string. You then lose another escape character per chunk when converting to the regular expression.


# 14.3.2 Anchors

It is often useful to anchor the match of a string to just the beginning or end of the string. This can be done using "^" to denote making a match to just the start or "$" for just the end of a string. Note that this is exactly the same as in Python. 

```{r match_endpts}
x <- c('apple', 'banana', 'pear')
str_view(x, '^a') # Only highlight the a of apple since it is at the start of the string
str_view(x, 'a$') # Only highlight the end a of banana since it is at the end
```

These characters can be used to force a match to only a single word by surrounding the word/expression with ^ and $.

```{r match_single_word}
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")
str_view(x, '^apple$')
```

This can also be defined using \\b to surround the word to be searched (e.g., \\bsum\\b).


## 14.3.2.1 Exercises

1 - How would you match the string literal "\$^\$"?

Including the quotes surrounding the dollar signs, you would use - '"\\\$\\^\\\$"'.

Without the quotes, you would use - '\\\$\\^\\\$'.

Without the quotes and without any extra characters, you would use - '\^\\\$\\^\\\$$'.

Note how you need two escape characters to escape the escape characters when making the string for the regular expression, like before. As proof - 

```{r Ex_2.1}
match <- '"\\$\\^\\$"'
writeLines(match)
str_view('"$^$"', match)
# Without quotes
match_noquote <- '\\$\\^\\$'
writeLines(match_noquote)
str_view(c('a$^$b', '$^$'), match_noquote)
# Exact, without quotes
match_exact_noquote <- '^\\$\\^\\$$'
writeLines(match_exact_noquote)
str_view(c('a$^$b', '$^$'), match_exact_noquote)
```


2 - Make regular expression to find words with the following patterns - 

Start with y - ^y.+ (Note that the .+ indicates any character at least once after y)

End with x - .+x$

Are exactly three letters long - ^...$

Have 7 or more letters .{7,} (Note that the brackets indicate that a character must be present at least 7 times, so the word must be at least 7 characters long)

For examples -  

```{r Ex_2.2}
x <- c('yak', 'xylophone', 'regex', 'raccoon', 'cat', 'cox')
# Starts with y
str_view(x, '^y.+')
# Ends in x
str_view(x, '.+x$')
# Exactly 3 letters long
str_view(x, '^...$')
# Seven or more letters
str_view(x, '.{7,}')
```

# 14.3.3 Character classes and alternatives

There are many special patterns that match more than one characters. We have already looked at the period, ., which matches any character except a newline. There are four other useful special tools commonly used in regex - 

\\d matches any digit 

\\s matches any white space (space, tab, newline, etc.) 

[abc] matches a, b, or c in that location of the expression

[^abc] matches anything except a, b, or c in that location of the expression

Remember that to create the expressions for \\d and \\s, which contain the escape character, you need to escape the backslash when creating the string by using two backslashes.

A character class (the square brackets surrounding a character/characters) containing a single character is a nice alternative to backslash escapes when you want to include a single metacharacter in a regex. It often makes it more readable, too.

```{r character_classes}
# Look for a literal character that normally has a special meaning in regex
x <- c('abc', 'a.c', 'a*c', 'a c')
str_view(x, 'a[.]c') # Gives the same results as str_view(x, 'a\\c')
# Gives different results than just the dot - 
str_view(x, 'a.c') # Matches all input strings
str_view(x, '.[*]c') # Matches only the string with the asterisk
str_view(x, 'a[ ]') # Matches only the string with the space
```

This works for most, but not all, of the regex metacharacters: $ . | ? * + ( ) [ {. A few still must be escaped with a backlash, however: ] \\ ^ and -. 

The straight pipe, |, can be used to pick between one or more alternative patterns. Note that the precednece is low for |, however, so it will only match the entire strings surrounding the pipe (like abc|xyz will only match abc and xyz). To change the precedence for |, you must use parentheses.

```{r alteration_with_pipe}
x <- c('gray', 'grey')
str_view(x, 'gr(e|a)y') # Matches both
str_view(x, 'gre|ay') # Only matches the parts for each word, not the entire word
```

## 14.3.3.1 Exercises

1 - Create regular expressions to find all words that:

Start with a vowel - \^[aeiou].+   (Note that I didn't put y because y is only sometimes a vowel).

Contain only consonants - \^[\^aeiou]+$

End with ed but not eed - .+[\^e]ed$

End with ing or ise - .+(ing|ise)$

For examples - 

```{r Ex_3.1}
x <- c('orange', 'pepper', 'lynx', 'sphynx', 'tweed', 'rowed', 'biking', 'exercise', 'mug',
       'plants', 'oxygen')
# Start with a vowel
str_view(x, '^[aeiou].+')
# Contains only consonants
str_view(x, '^[^aeiou]+$')
# Ends with ed but not eed
str_view(x, '.+[^e]ed$')
# Ends with ing or ise
str_view(x, '.+(ing|ise)$')
```


2 - Empirically verify the rule 'i before e except after c'

This could be checked by counting the number of instances of words in a repository (like a dictionary or stringr::words) that follow and don't follow the rule. To check for words that follow and don't follow the rule, use the regular expressions - [^c]ie and cie, respectively. To count the number of entries in a set that do follow a regular expression, you can use str_extract and counting the number of entries that don't return NA (since this function returns NA for entries that do not contain the pattern). As an example, count the number of entries in the stringr::words word set (980 words) that do and don't follow the rule. 

```{r Ex_3.2}
follow <- sum(!is.na(str_extract(stringr::words, '([^c]ie)|(cei)')))
follow
do_not_follow <- sum(!is.na(str_extract(stringr::words, 'cie')))
do_not_follow 
```

Fourteen entries do follow the rule while two don't. Of course, a more complete understanding of the ratio of words that do and don't follow the "rule" can be discovered by using a much larger data set, such as all the words in an online dictionary. 


3 - Is q always followed by u?

Use the following regular expression - q[^u] - and the above counting procedure on the stringr word set to see if any entries in this word set do not follow this rule.

```{r Ex_3.3}
qu <- sum(!is.na(str_extract(stringr::words, 'q[^u]')))
qu
# There are 10 total entries with the letter q - 
sum(!is.na(str_extract(stringr::words, 'q')))
```

At least in the stringr word set, all entries with a q have a subsequent u. More words are needed to determine if there are any or how many words in the English language have a q without a subsequent u.


4 - Write a regular expression that matches a word if it's probably written in British English but not American English. 

I'm going to assume that it means the 'our' ending for British English words instead of 'or' in many American English words, such as 'colour' and 'labour' for British English and 'color' and 'labor' for American English. I'll also do the 'ise' and 'ize' verb endings for British and American English, respectively (although British can apparently do either, American does 'ize' only). 

```{r Ex_3.4}
# Use a simple word set of contrasting words for demonstration
word_set <- c('color', 'colour', 'labor', 'labour', 'recognize', 'recognise',
           'organize', 'organise')
Brit_ou <- str_view(word_set, '.+our$')
Brit_ou
Brit_ise <- str_view(word_set, '.+ise$')
Brit_ise
Both <- str_view(word_set, '.+((our)|(ise))$')
Both 
```


5 - Create a regular expression that will match telephone numbers as commonly written in your country.

In the US, numbers are fully written in a +1 NXX-NXX-XXXX format for numbers dialed within the US, with the first 1 being the country code for the US. N = 2-9 and X = 0-9. The first 3 digit chunk is the area code while the subsequent 7 are the subscriber/line number. Using this as the format, the regular expression can be written as follows - '[+]1 [2-9]\\\d{2}-[2-9]\\\d{2}-\\\d{4}'. Note that two backslashes are required to escape the backslash when making the string so it can be created into the regular expression. Here is the regular expression matched against a series of standard US and nonstandard telephone numbers for demonstration.

```{r Ex_3.5}
# Only the first two are in standard format
phone_numbers <- c('+1 987-654-3210', '+1 963-852-7410', '+1 012-345-6789',
                   '+2 987-654-3210', '+1 987-012-3456', '1 987-654-3210')
str_view(phone_numbers, '[+]1 [2-9]\\d{2}-[2-9]\\d{2}-\\d{4}') # Only matches the first two
```


# Repetition

There are some special metacharacters that can control the number of times a pattern matches. These include - 

? for 0 or 1 matches

+ for 1 or more matches 

* for 0 or more matches

```{r repetition}
x <- '1888 is the longest year in Roman numerals: MDCCCLXXXVIII'
str_view(x, 'CC?')
str_view(x, 'CC+') # Matches the first 3 Cs
str_view(x, 'C[LX]+') # Matches from the last C to the last X
# Extra messing around with the operators - 
str_view(x, 'C+LX+') # Matches from first C to last X
str_view(x, '[MDCLXVI]?') # No matches
str_view(x, 'M[DCLXVI]?') # Matches the first two Roman numerals
str_view(x, '[MDCLXVI]+') # Matches the entire Roman numeral set
str_view(x, '[MDCLXVI]*') # No matches
str_view(x, 'M[DCLXVI]*') # Matches the entire Roman numeral set
str_view(x, '[MDCLXVI]{6}') # Matches the first six Roman numerals
```

It seems like the metacharacters that have 0 as a possible number of matches (? and *) require a sort of seed to start the match before they are able to match anything, but when they have that seed, they then are greedy in that they match as many characters as possible.

Also, note that the precedence of these operators is high, so to match a single character, just put the metacharacter directly behind the single character (e.g., colou?r to match colour and color). To match multiple repeating characters, however, they must be inside parentheses (e.g., bana(na)+).

To specify the number of matches precisely, use curly brackets - 

{n} for exactly n matches

{n,} for at least n matches

{,m} for at most m matches

{n,m} for between n and m matches

This works with both single characters and character sets inside square brackets.

```{r precise_repetition}
str_view(x, 'C{2}') # First 2 Cs
str_view(x, 'C{2,}') # All 3 Cs
str_view(x, 'C{1,3}') # All 3 Cs. Also, I tried to not specify a min and it didn't work
str_view(x, '[CLX]{6}') # Matches six characters starting with the first C
```

As described above, these operators (including the curly brackets) are greedy by default in that they will match the longest string possible. To make them "lazy" and match the shortest string possible, a ? must be put after them. This works with both curly brackets and the metacharacters.

```{r precise_repetition_lazy}
str_view(x, 'C{2,3}?') # 'Lazy', so only matches the first 2 Cs
str_view(x, 'C[LX]+?') # Also 'Lazy', so only matches the first CL (no Xs)
str_view(x, 'C[LX]??') # Matches only the C. Would not recommend doing this since the character set is useless
```


## 14.3.4.1 Exercises

1 - Describe the equavalents of ?, +, and * in {n,m} form.

? = {0,1}

+ = {1, }

* = {0, }


2 - Describe in words what these regular expressions match - 

^.*$ = Any string. Carot = start, period and asterisk = any number of characters, and dollor sign = end.

"\\\\{.+\\\\}" = Any string that contains at least one character surrounded by curly brackets

\\d{4}-\\d{2}-\\d{2} = A string with four numbers (0-9), a hyphen, 2 numbers, a hyphen, then two numbers.

"\\\\\\\\{4}" = Four backslashes in a row.

For demonstration, here are a series of string sets and the regular expressions to show what they do.

```{r Ex_4.2}
# first
x <- c('.', '.a', 'a', '.ab', '  a  s')
str_view(x, '^.*$')
# second
x <- c('a', '{}', '{a}', '{AB}')
str_view(x, "\\{.+\\}")
# third
x <- c('1111-11-11', '5847-56-23', '058-1721-2', '00000000')
str_view(x, '\\d{4}-\\d{2}-\\d{2}')
# fourth
x <- c('\\', '\\\\', '\\\\\\', '\\\\\\\\', '\\\\\\\\\\')
writeLines(x)
str_view(x, '\\\\{4}')
```


3 - Create regular expressions that find all words that:

Start with three consonants - \^[\^aeiou]{3}

Have three or more vowels in a row - .\*[aeiou]{3,}.\*

Have two or more vowel-consonant pairs in a row - ([aeiou][^aeiou]){2,}

For demonstration,

```{r Ex_4.3}
# Start with three consonants
x <- c('sphinx', 'lynx', 'tire', 'string', 'lawbook')
str_view(x, '^[^aeiou]{3}.*')
# For only three consonants,
str_view(x, '^[^aeiou]{3}[aeiou].*')
# Have three or more vowels in a row
x <- c('congruous', 'conscientious', 'continuous', 'aeiou', 'extreme', 'value')
str_view(x, '.*[aeiou]{3,}.*')
# Have two or more vowel-consonant pairs in a row
x <- c('banana', 'care', 'potato', 'arrange', 'inept', 'rear', 'average', 'bottle',
       'apple', 'pepper', 'Gibbs')
str_view(x, '.*([aeiou][^aeiou]){2,}.*') # vowel-consonant patterns only, not consonant-vowel
```


4 - I solve the crosswords but forgot to take a screenshot before exiting the tab. Whoops.


# 14.3.5 Grouping and backreferences

Parentheses, in addition to separating different parts of a regex, also create numbered capturing groups that can be references in a later part of the regular expression. The groups are stored as numbers and can be referenced using \\# (like \\1, \\2, etc.).This allows for easy and quick searching for repetitive patterns of the exact same characters. For example, the following regular expression finds all frutis that have repeated pairs of letters.

```{r backreferences}
str_view(fruit, '(..)\\1', match = TRUE) # Don't forget the double escape for the regex
# Also, note that the match = TRUE argument shows only the matching characters
```

## 14.3.5.1 Exercises

1 - Describe, in words, what these expressions will match:

(.)\\1\\1 = Any character that is repeated three times in a row (e.g., aaa).
"(.)(.)\\\\2\\\\1" = Any character set that has the reverse first two characters directly after these first two characters (e.g., abba). In genetics, this would be an inverted repeat.
(..)\\1 = Any character set that has the first two characters directly repeated (e.g., abab). In genetics, this would be a direct repeat.
"(.).\\\\1.\\\\1" = A 5-character string (or part of a string) that has the first character repeated every two characters with any character between the repeated one (e.g., abaca).
"(.)(.)(.).*\\\\3\\\\2\\\\1" = Any character set that has the reverse of the first three characters repeated after any number of characters between the inverted repeat (e.g., abcddddcba, abccba, abcdefcba).
Examples - 

```{r Ex_5.1}
# First
x <- c('a', 'aa', 'aaa', 'aaaa', 'bbb', 'bab')
match <- '(.)\\1\\1'
writeLines(match)
str_view(x, match)
# Second
x <- c('abab', 'abba', 'baab', 'baba', 'bababa', 'baabba')
match <- "(.)(.)\\2\\1"
writeLines(match)
str_view(x, match)
# Third
match <- '(..)\\1'
writeLines(match)
str_view(x, match) # Same set of strings as second part
# Fourth
x <- c('abaca', 'banana', 'abcde', 'abcda', 'abab')
match <- "(.).\\1.\\1"
writeLines(match)
str_view(x, match)
# Fifth
x <- c('abcdddcba', 'abccba', 'abcdefcba', 'abcdabcd')
match <- "(.)(.)(.).*\\3\\2\\1"
writeLines(match)
str_view(x, match)
```


2 - Construct regular expressions to match words that:

Start and end with the same character = '^(.).\*\\\\1\$' (without quotes, \^(.).\*\\1$)

Contain a repeated pair of letters = '([A-Za-z][A-Za-z]).\*\\\\1' (without quotes, ([A-Za-z][A-Za-z]).\*\\1)

Contain one letter repeated in at least three places = '([A-Za-z]).\*\\\\1.\*\\\\1' (without quotes, ([A-Za-z]).\*\\1.\*\\1)

Examples - 

```{r Ex_5.2}
# Start and end with the same character
x <- c('abra', 'kadabra', 'abrakadabra', 'banana', 'stoats', 'curtains')
match <- '^(.).*\\1$'
str_view(x, match)
# Contain a repeated pair of letters (NOT numbers)
x <- c('church', 'banana', 'kiwi', 'abcdefgab', '126541')
match <- '([A-Za-z][A-Za-z]).*\\1'
str_view(x, match)
# Contains one letter repeated in at least three different places
x <- c('water bottle', 'totality', 'concoction', 'eleven',
       'crocodile', 'alligator', '12131')
match <- '([A-Za-z]).*\\1.*\\1'
str_view(x, match)
```


# 14.4 Tools

Now that the basics of regular expressions has been covered, it is time to apply them to real problems. This section will cover an array of stringr functions that will use these regular expressions to find and manipulate patterns, including determining which strings match a pattern, finding the positions of hte matches, extracting the contents of matches, replacing matches with new values, and splitting a string based on a match. 


# 14.4.1 Detect matches

To determine if a character vector entry matches a pattern, use str_detect(), which returns a logical vector of the same length of the input vector with TRUE/FALSE for all entries based on if a match is found or not.

```{r detect}
x <- c('apple', 'banana', 'pear')
str_detect(x, 'e')
```

Remember that logic vectors resolve to 0 for FALSE and 1 for TRUE in a numeric context, so you can use sum() to count the number of matches in a large vector and other functions, like mean(), to investigate the contents in a large vector.

```{r count_matches}
# How many of the common words in the words set start with t?
sum(str_detect(words, '^t'))
# What proprotion of these common words end with a vowel?
mean(str_detect(words, '[aeiou]$'))
```

When you have a complex logical condition or conditions (such as matching a or b but not c unless d), it is often easier to combine multiple str_detect() functions with logical operators rather than trying to create a single, complex regular expression. This could be done by breaking the regular expression into smaller pieces and analyzing the set with each smaller regular expression, then combining the pieces with logical operators. The following are two ways to find all words that don't contain any vowels to show a more concise and more complex way: 

```{r more_complex}
# Method 1 - find all words that contain at least one vowel and negate them 
no_vowels_1 <- !str_detect(words, '[aeiou]')
# Method 2 - find all words consisting of only consonants (non-vowels)
no_vowels_2 <- str_detect(words, '^[^aeiou]+$')
identical(no_vowels_1, no_vowels_2) # Check that the results are the same
```

A common use of str_detect() is to select elements that match the input pattern, which can be done with logical subsetting or even the convenient str_subset() wrapper function:

```{r detect_subset}
words[str_detect(words, 'x$')] # Words that end with x
str_subset(words, 'x$') # More convenient way to subset the words that end with x

# In a data frame, strings will typically be in a column, so you'll use filter() instead
words[str_detect(words, 'x$')] # Words that end with x
str_subset(words, 'x$') # More convenient way to subset the words that end with x
# For a column in a data frame, you will want to use filter() instead
df <- tibble(word = words, i = seq_along(word)) # Make a tibble of the words set
# seq_along() gives the position of the word in the words word set
df %>% 
  filter(str_detect(word, 'x$'))
```

A variation of str_detect() is str_count(), which returns the number of matches found within a string. 

```{r string_count}
x <- c('apple', 'banana', 'pear')
str_count(x, 'a')
# On average, how many vowels are there per word in the words word set?
mean(str_count(words, '[aeiou]'))

# For data frames, it is common to use str_count() with mutate()
df %>% 
  mutate(
    vowels = str_count(word, '[aeiou]'),
    consonants = str_count(word, '[^aeiou]'))
```

However, like in Python, note that the matches never overlap. For example, in the word "abababa", the pattern "aba" will only match two times, not three.

```{r nonoverlapping_matches}
str_count('abababa', 'aba')
str_view_all('abababa', 'aba')
```

As you can see in the above str_view_all() function, all matches are shown. In stringr, many functions come in pairs - one to find a single match, and one to find all matches (typically with the suffix "_all").


## 14.4.1.1 Exercises

1 - For each of the following challenges, try solving it using both a single regular expression and with a combination of multiple str_detect() calls.
Find all words that start or end with x

```{r Ex_4.1.1.1}
# Method 1 - single regex
start_end_x_1 <- words[str_detect(words, '^x|x$')]
start_end_x_1
# Method 2 - Two regex
start_x <- words[str_detect(words, '^x')] # No words
end_x <- words[str_detect(words, 'x$')] # Four words
start_end_x_2 <- c(start_x, end_x)
start_end_x_2
# Check that they are identical
identical(start_end_x_1, start_end_x_2)
```

Find all words that start with a vowel and end with a consonant

```{r Ex_4.1.1.2}
# Method 1 - single regex
vowel_consonant_1 <- words[str_detect(words, '^[aeiou].*[^aeiou]$')]
vowel_consonant_1
# Method 2 - two regex
start_vowel <- str_detect(words, '^[aeiou]')
end_consonant <- str_detect(words, '[^aeiou]$')
vowel_consonant_2 <- words[start_vowel & end_consonant]
vowel_consonant_2
# Check that all entries are identical
identical(vowel_consonant_1, vowel_consonant_2)
```

Are there any words that contain at least one of each different vowel?

```{r Ex_4.1.1.3}
# Method 1 - single regex
# To do in a single regex, all possible orders of the vowels must be constructed
# with '.*' between them for any possible characters between the vowels. To do this,
# all permutations of the vowels must be created (5! = 120 variants). Based on some 
# Googling, I found a function to list all permutations in a matrix (found at 
# https://stackoverflow.com/questions/11095992/generating-all-distinct-permutations-of-a-list-in-r).
# This function returns a matrix of all permutations, with a permutations per row and 
# the order of each element in each column
permutations <- function(n){
  if(n==1){
    return(matrix(1)) # Return a matrix of 1 if 1 is entered
  } else {
    sp <- permutations(n-1) # Recursive until 1 is reached
    p <- nrow(sp)
    A <- matrix(nrow=n*p,ncol=n) # Define the size of the matrix
    for(i in 1:n){
      A[(i-1)*p+1:p,] <- cbind(i,sp+(sp>=i)) # Make the elements of the matrix
    }
    return(A)
  }
}
# For example, for a permutation of 4,
head(permutations(4))
# To make a permutation for all five vowels, make a vector of all vowels, 
# turn the matrix into a data frame, unite an additional column to combine 
# the permutation elements into one with the ".*" between each element, and
# finally combine all entries into one string, with each entry separated by 
# a pipe, |
vowels <- c('a','e','i','o','u')
vowels_df <- as_tibble(matrix(vowels[permutations(5)], ncol = 5))
head(vowels_df) # Looks correct
# Now unite to get the combined column
vowels_unite <- unite(vowels_df, string, V1, V2, V3, V4, V5, sep = '.*')
head(vowels_unite)
pattern <- character(0) # Make the initial string object for the regex pattern
for (string in vowels_unite$string) {
  pattern <- paste(pattern, string, sep = ')|(')
} 
pattern <- paste(substr(pattern, 3, nchar(pattern)), ')', sep = '') # properly format the pattern
pattern
# Now, test with a positive and negative case to make sure the pattern works
str_view('authorize', pattern) # Works as expected
str_view('promote', pattern)
# Finally, use the pattern to find any words with all vowels in words
all_vowels_1 <- words[str_detect(words, pattern)]
all_vowels_1 # There are none. Great

# Method 2 - multiple regex
a <- str_detect(words, 'a')
e <- str_detect(words, 'e')
i <- str_detect(words, 'i')
o <- str_detect(words, 'o')
u <- str_detect(words, 'u')
all_vowels_2 <- words[a & e & i & o & u]
all_vowels_2 # There are none
```

Altogether, this last one was much, much easier with the multiple regex instead of a single, humongous one.


2 - What is the word/words with the most vowels in the words word set, and what is the word/words with the highest proportion of vowels?

```{r Ex_4.1.2}
# Most vowels - 
words_df <- tibble(word = words, i = seq_along(words), 
                   num_vowels = str_count(words, '[aeiou]'),
                   prop_vowels = str_count(words, '[aeiou]')/nchar(words))
head(words_df) # Looks correct
most_vowels <- words_df %>% 
  arrange(desc(num_vowels)) %>% 
  # Select all words with the highest number of vowels
  slice(1:sum(words_df$num_vowels == max(words_df$num_vowels)))
most_vowels # There are 8 words in the words data set that have the most vowels

# Highest proportion of vowels - same process
highest_prop_vowels <- words_df %>% 
  arrange(desc(prop_vowels)) %>% 
  slice(1:sum(words_df$prop_vowels == max(words_df$prop_vowels)))
highest_prop_vowels # Only a is created. One further thought, I should be included, too
```

Appropriate, associate, available, colleague, encourage, experience, individual, and television all have the most number of vowels (5) in the words set. Only a has the highest proportion of vowels in the words set since it is only a vowel (although I could also be included if it was in the words set). 


# 14.4.2 Extract matches

To extraact the actual text of a match, use str_extract(), which will extract the exact match only (no surrounding characters). To work with this, we will use the Harvard sentences word set from stringr::sentences.

```{r investigate_sentences}
length(sentences)
head(sentences)
```

Now, let's find all sentences that contain a colour from the rainbow. First, create a vector of coloured names and turn it into a single regular expression using str_c(), which joins all elements of a vector with a given separator specified by the argument 'collapse'. Then, use str_subset() to extract the sentences with a colour (just like x[str_detect(x, regex)]) and str_extract() to extract the matched colour.

```{r colour_regex}
colours <- c('red', 'orange', 'yellow', 'green', 'blue', 'purple')
colour_match <- str_c(colours, collapse = '|') 
# str_c() joins all elements of a vector with a given separator specified by collapse
colour_match
# Now select the sentences that have a colour and extract the colours
has_colour <- str_subset(sentences, colour_match) 
# str_subset() returns the elements that have the given regex; = x[str_detect(x, regex)]
matches <- str_extract(has_colour, colour_match) # Extract the colours
head(matches)
```

However, the above example has an error. If you look at the matches sentences and the extracted matched colours, you will find that for the sentences with multiple colors, str_extract() only extracted the first match. This is most easily seen by investigating the sentences with more than one match.

```{r multiple_color}
more <- sentences[str_count(sentences, colour_match) > 1]
str_view_all(more, colour_match)
# str_view() doesn't highlight multiple colors, however
str_view(more, colour_match)
# Now test extracting using str_extract() and str_extract_all()
str_extract(more, colour_match) # This returns a simple vector
str_extract_all(more, colour_match) # This returns a nested vector
```

As stated before, this is a common pattern in stringr functions (the base only matches the first match while *_all() matches all matches) because working with single matches creates much simpler data structures. 

You can specify simplify = TRUE in str_extract_all() to create a simpler matrix with short matches expanded to the same length as the longest, as in more (empty) entries are added to the matrix for the shorter matches. For example, 

```{r extract_all_simplify}
str_extract_all(more, colour_match, simplify = TRUE)
x <- c('a', 'a b', 'a b c') 
str_extract_all(x, '[a-z]', simplify = TRUE)
```


## 14.4.2.1 Exercises

1 - Fix the previous example's regex to pick only colours, not words with a colour somewhere in the word (like 'flickered').
To fix it, just put a space before and after the color for the regex to match.

```{r Ex_4.2.1}
colours_fixed <- paste(' ', str_c(colours, collapse = ' | '), ' ', sep = '')
colours_fixed
# To show that it only extracts colors now, 
has_colour_fixed <- str_subset(sentences, colours_fixed)
has_colour_fixed
```


2 - From the Harvard sentences data, extract: 
The first word from each sentence

```{r Ex_4.2.2.1}
head(str_extract(sentences, '^[A-Za-z]*'), 10)
# Using head() to make sure the output isn't too long
```
All words that end with ing

```{r Ex_4.2.2.2}
ing_detect <- str_subset(sentences, '[A-Za-z]*ing')
head(str_extract_all(ing_detect, '[A-Za-z]*ing', simplify = TRUE))
```

All plural words

```{r Ex_4.2.2.3}
# Assume all plurals end with 'es' or '[consonant]s', so words like 'as' 
# aren't matched. Also, don't match apostrophes, duplicate s, and spaces.
plural_detect <- str_subset(sentences, "[A-Za-z]*[^aious ']s ")
head(str_extract_all(plural_detect, "[A-Za-z]*[^aious ']s ", simplify = TRUE))
# Unfortunately, this also catches present-tense action verbs, but that can't be easily 
# overcome without a much hardier code
```


# 14.4.3 Grouped matches

As shown earlier in the chapter, parentheses can be used for both clarifying precedence in a regex and for referencing parts of a match later in the regex (backreferences). Additionally, parentheses can be used to extract parts of a complex match. For example, let's extract nouns from the sentences in the sentences word set. We'll use the simple heuristic that a noun comes after the word 'a' or 'the', and we'll define a word in the regex as any sequence of characters that is at least one character long and isn't a space.

```{r extract_nouns}
noun <- '(a|the) ([^ ]+)' # Define the pattern for finding the nouns

has_noun <- sentences %>% 
  str_subset(noun) %>% 
  head(10)
has_noun %>% 
  str_extract(noun)
```

str_extract() give the complete match while str_match() gives each individual component of the match in a matrix, with one column for the complete match and subsequent columns for each individual group.

```{r noun_grouped_matches}
has_noun %>% 
  str_match(noun)
```

As you can see, the heuristic is relatively poor as it matches adjectives instead of nouns as well.

If the data is in a tibble, it is often easier to find matches using tidyr::extract(), which works much like str_match() but also requires names for each of the groups of the match, which are then  placed into the columns of the tibble created for the matches.

```{r nouns_grouped_matches_tibble}
tibble(sentence = sentences) %>% 
  tidyr::extract(
    sentence, c('article', 'noun'), noun,
    remove = FALSE
)
```

Note that it outputs a result for all sentences, including the ones where no match was detected. Additionally, setting remove = FALSE will keep the data that was matched (in this case, the sentences) in the output tibble. Like for most stringr functions, str_match_all() will output all matches for each input string.


## 14.4.3.1 Exercises

1 - Find all words that come after a number, and pull out both the number and the word.
For ease, I will just choose the numbers one through ten.

```{r Ex_4.3.1}
numbers <- c('one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten')
pattern <- paste('\\b(', str_c(numbers, collapse = '|'), ') ([^ ]+)',  sep = '')
pattern # Recall that \b detects only the independent word (so it won't detect 'stone')
str_view('ten owls', pattern) # Works as expected
numbered_sentences <- str_subset(sentences, pattern)
str_match_all(numbered_sentences, pattern)
```


2 - Find all contractions, then separate out the pieces before and after the apostrophe.

```{r Ex_4.3.2}
contraction_sentencs <- str_subset(sentences, "([A-Za-z]+)'([^ ]+)")
str_match_all(contraction_sentencs, "([A-Za-z]+)'([^ ]+)")
```


# 14.4.4 Replacing matches

To replace matches with new strings, use str_replace() for the first match and str_replace_all() for all matches. For example, to replace the input pattern of string with a new text, str_replace(string, pattern, new_text). The simplest use is to replace a pattern with a fixed string.

```{r replace_simple}
x <- c('apple', 'pear', 'banana')
str_replace(x, '[aeiou]', '-') # Again, note that only the first match is replaced
str_replace_all(x, '[aeiou]', '-') # Now all matches are replaced
```

You can do multiple replacements with str_replace_all() by supplying a named vector that specifies each match and its corresponding replacement.

```{r replace_multiple}
x <- c('1 house', '2 cars', '3 people')
str_replace_all(x, c('1' = 'one', '2' = 'two', '3' = 'three'))
```

Backreferences can also be used to insert/flip around components of a match. The following example flips the order of the second and third words from a portion of the sentences word set.

```{r replace_backreferences}
sentences %>% 
  str_replace('([^ ]+) ([^ ]+) ([^ ]+)', '\\1 \\3 \\2') %>% 
  head(5)
```


## 14.4.4.1 Exercises

1 - Replace all forward slashes in a string with backslashes.
For some unknown reason, R won't replace with a single backslash (see below), so I was only able to replace with two backslashes.

```{r Ex_4.4.1}
# For some unknown reason, the following doesn't work - 
str_replace_all(string, '/', '\\')
str_replace_all(string, '/', '\\\\') # Can only replace with multiple backslashes
```


2 - Implement a simple version of str_to_lower() using str_replace_all().
str_to_lower(), as the name implies, takes a string and replaces all uppercase characters with lowercase. Therefore, make a vector with uppercase characters corresponding to their respective lowercase characters and use it to replace uppercases in a string.

```{r Ex_4.4.2}
letter_cases <- c('A' = 'a', 'B' = 'b', 'C' = 'c', 'D' = 'd', 'E' = 'e', 'F' = 'f',
                  'G' = 'g', 'H' = 'h', 'I' = 'i', 'J' = 'j', 'K' = 'k', 'L' = 'l', 
                  'M' = 'm', 'N' = 'n', 'O' = 'o', 'P' = 'p', 'Q' = 'q', 'R' = 'r', 
                  'S' = 's', 'T' = 't', 'U' = 'u', 'V' = 'v', 'W' = 'w', 'X' = 'x',
                  'Y' = 'y', 'Z' = 'z')
str_replace_all('ABCDEFGHIJKLMNOPQRSTUVWXYZ', letter_cases)
string <- 'CrAzYcAsEs ArE rIdIcUlOuS aNd WeIrD tO rEaD.'
str_replace_all(string, letter_cases)
```


3 - Switch the first and last letters in words. Which of these strings are still words?

```{r Ex_4.4.3}
swap_first_last <- str_replace(words, '(.)(.+)(.)', '\\3\\2\\1')
head(swap_first_last, 10)
# To roughly find which ones are still words, choose the words that are the same in 
# the words and swap_first_last word sets using intersect()
still_words <- intersect(swap_first_last, words)
still_words
# However, note that some words with their first and last letters replaces are still 
# words, such as 'bad' to 'dab':
swap_first_last[68]
# To find all words like this, the list would have to be manually inspected or compared to 
# a complete list of words in the English dictionary.
```


# 14.4.5 Splitting

str_split() splits a string into pieces based on the input delimiter, returning a list of the split string with the delimiter removed (like the .split() method in Python). For example, split a sentences into words using the space character as the delimiter - 

```{r basic_split_words}
sentences %>% 
  head(5) %>% 
  str_split(' ')
```

If you are working with a length-1 vector, the easiest way to extract the results cleanly is to just extract the first element of the list.

```{r split_extract_from_list}
'a|b|c|d' %>% 
  str_split('\\|') %>% 
  .[[1]] # This extracts just the first element of the resulting list 
```

Otherwise, you can specify the simplify = TRUE argument (like in other stringr functions that return lists) to return an ordered matrix - 

```{r split_return_matrix}
sentences %>% 
  head(5) %>% 
  str_split(' ', simplify = TRUE)
```

You can also request a maximum number of pieces to return using the 'n' argument so that only the first n strings resulting from the split are returned (or the unsplit string if there aren't enough pieces to return). 

```{r split_specify_pieces}
fields <- c('Name: Hadley', 'Country: NZ', 'Age: 35')
fields %>% str_split(': ', n = 2, simplify = TRUE) # Returns both pieces
fields %>% str_split(': ', n = 1, simplify = TRUE) # Returns the unsplit string
str_split('a|b|c|d', '\\|', n = 2, simplify = TRUE) # Last entry is unsplit
str_split('a|b|c|d', '\\|', n = 3, simplify = TRUE)
```

You can also split strings up by character, line, sentence, and word using the boundary() function from stringr. This function defines regex boundaries based on the input type. 'Character' breaks by each character, 'line_break' breaks by the locale's line break character, 'sentence' breaks by sentence, and 'word' breaks by word. For example,

```{r split_boundary}
x <- 'This is a sentence. This is another sentence.'
str_view_all(x, boundary('word')) # Note how the period is not highlighted
str_view_all(x, boundary('character'))
str_view_all(x, boundary('sentence'))
str_view_all(x, boundary('line_break'))
str_split(x, ' ')[[1]]
str_split(x, boundary('word'))[[1]] # Gives similar results, just no periods
```


## 14.4.5.1 Exercises

1 - Split up a string like 'apples, pears, and bananas' into individual components.
```{r Ex_4.5.1}
tundra_animals <- 'bears, wolves, and caribou'
ind_tundra_animals <- str_split(str_replace_all(tundra_animals, c('and' =  '', ' ' = '')), ',',
                                       simplify = TRUE)
ind_tundra_animals
```


2 - Why is it better to split up by boundary('word') than ' '?
Splitting words via boundary('words') will also remove any punctuation (like periods) from the split words, as evidenced by the highlighted words above.


3 - What does splitting an empty string do?
This splits the input string by characters, which "is equivalent to boundary('character')", as the documentation states. 
```{r Ex_4.5.3}
str_split('dog', '') # Single word
str_split('The quick brown dog jumped over the lazy fox.', '') # Sentence
```


# 14.7 stringi

stringr is built upon the stringi package. stringr is useful when learning since it contains the minimal set of functions that are used most often. On the other hand, stringi is much more comprehensive, with 250 functions vs stringr's 49. If trying to do something in stringr is difficult, it may be worth looking into stringi. stringi works very similarly, so translating between the two packages should be easy. The main difference is the prefix - str_ for stringr vs stri_ for stringi.

# Reference